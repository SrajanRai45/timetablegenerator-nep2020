
import { serve } from "https://deno.land/std/http/server.ts"
import { createClient } from "https://esm.sh/@supabase/supabase-js@2"

// WARNING: Do not expose your Gemini API key on the client-side.
// Use Supabase Secrets to store it securely.
const GEMINI_API_KEY = Deno.env.get("GEMINI_API_KEY")
const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${GEMINI_API_KEY}`

// Simple validation for a timetable entry
function isValidEntry(entry: any): boolean {
  const requiredKeys: (keyof typeof entry)[] = [
    "term_id",
    "day",
    "timeslot_id",
    "offering_id",
    "room_id",
    "faculty_id",
  ]
  return requiredKeys.every(key => key in entry)
}

serve(async (req) => {
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  }
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders })
  }

  try {
    const supabaseAdmin = createClient(
      Deno.env.get("SUPABASE_URL") ?? "",
      Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "",
    )

    const { term_id } = await req.json()
    if (!term_id) {
      throw new Error("Missing required parameter: term_id")
    }

    const [rooms, faculty, timeslots, offeringsResult] = await Promise.all([
      supabaseAdmin.from("room").select("*"),
      supabaseAdmin.from("faculty").select("*"),
      supabaseAdmin.from("timeslot").select("*").eq("term_id", term_id),
      supabaseAdmin.from("course_offering").select("*, course(*)").eq("term_id", term_id),
    ])

    const offerings = offeringsResult.data?.map(o => ({ ...o, course: Array.isArray(o.course) ? o.course[0] : o.course }))

    const prompt = `
      You are an expert university timetable scheduler. Your task is to generate a valid, conflict-free timetable.
      **CONTEXT:**
      Here are the available resources and constraints for the term (term_id: ${term_id}).
      **1. Available Rooms:**
      ${JSON.stringify(rooms.data, null, 2)}
      **2. Available Faculty:**
      ${JSON.stringify(faculty.data, null, 2)}
      **3. Available Time Slots (for this term):**
      ${JSON.stringify(timeslots.data, null, 2)}
      **4. Course Offerings to be Scheduled (for this term):**
      ${JSON.stringify(offerings, null, 2)}
      **TASK:**
      Generate a list of timetable entries to schedule all the course offerings. Adhere strictly to the following rules:
      - **No Conflicts:** A room, a faculty member, or a course offering section cannot be scheduled in the same timeslot on the same day more than once.
      - **Utilize All Resources:** You must use the provided room, faculty, and timeslot IDs.
      - **Complete Scheduling:** Attempt to schedule every course offering provided.
      **OUTPUT FORMAT:**
      You MUST return ONLY a valid JSON array of objects. Each object represents a single timetable entry and must have the following structure, with no extra text or explanations:
      [
        {
          "term_id": ${term_id},
          "day": "Mon", // Must be one of ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
          "timeslot_id": <ID from timeslots list>,
          "offering_id": <ID from offerings list>,
          "room_id": <ID from rooms list>,
          "faculty_id": <ID from faculty list>
        },
        ...
      ]
    `

    const geminiResponse = await fetch(GEMINI_API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        contents: [{ parts: [{ text: prompt }] }],
      }),
    })

    if (!geminiResponse.ok) {
      const errorBody = await geminiResponse.text()
      throw new Error(`Gemini API request failed: ${geminiResponse.status} ${errorBody}`)
    }

    const geminiResult = await geminiResponse.json()
    if (!geminiResult.candidates || geminiResult.candidates.length === 0) {
      throw new Error("No content generated by Gemini API.")
    }
    
    const generatedText = geminiResult.candidates[0].content.parts[0].text
    const cleanedText = generatedText.replace(/```json|```/g, "").trim()
    const newEntries = JSON.parse(cleanedText)

    if (!Array.isArray(newEntries) || !newEntries.every(isValidEntry)) {
      throw new Error("Invalid timetable data received from Gemini API.")
    }

    await supabaseAdmin.from("timetable_entry").delete().eq("term_id", term_id)
    const { error: insertError } = await supabaseAdmin.from("timetable_entry").insert(newEntries)

    if (insertError) {
      throw new Error(`Failed to insert new timetable entries: ${insertError.message}`)
    }

    return new Response(JSON.stringify({ message: `Successfully generated and saved ${newEntries.length} timetable entries.` }), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
      status: 200,
    })

  } catch (error) {
    return new Response(JSON.stringify({ error: error.message }), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
      status: 500,
    })
  }
})
